# 各种数据库设计指导规范

## 一. 注意
#### 1. 删除、下架、不可见等
- deleted_at 字段仅表示不可普通查，即仅用于保留重要数据，不可查询。
- is_available = 0 表示下架, 仅拥有者可编辑, 对他人不可见、不可用.
- is_active 判定比 is_available 弱, 是否可见应当使用 is_visible 或 xx_visible.

#### 2. 排序
- sort 或 power(非正式) 字段(decimal 格式)专用于排序, 请不要依靠 updated_at 字段排序

#### 3. 其他
- 若 code name(或 label) 同时出现, code 用于查询, name(或 label)用于显示, 请不要使用id 查询 [非强制]

---

## 二. 结构
### 1. 树形结构

#### 1). 字段
- `id` (不解释, 必需)
- `name` (必需)
- *code (用于查询 可省略)*
- *type (若本表为单类型, 则可省略)*
- `parent_id` (父ID, 根结点为 0, 必需)
- *is_available (状态, 其余 bool 状态也可按需添加)*
- level (结点层, 第几级)
- sort (排序, power 为非正式, decimal 格式)

#### 2). 附属表
- attribute (额外描述)
- scope (作用域, 与 map 同时出现, 多用于标签表)
- scope_map (多对多, 可实现同一结点在不同作用域下的差异表现)

#### 3). 特点
- 树的遍历为 **先根遍历**
- 树形结构由于每个结点都依附于父节点, 当一个结点的某个状态被关闭, 则其下方的所有 **子孙** 结点的该状态都被关闭, 但相反的, 其上方的所有 **祖先** 结点却不受影响
- 插入树 和 删除树 的规则同上, 即仅影响当前结点
- 排序为同一父结点的所有结点的排序, 这些结点之外的其余结点不受影响

### 2. 权限管理

#### 1). 表
- accout (用户 在用户模块中)
- role (角色)
- account_role (用户 - 角色表, 一般为 一对一)
- power (权限, route 路由)
- role_power (角色 - 权限表 多对多)
- *account_power* (用户 - 权限表 用于定义特殊权限)
- *account_level* (用户分级 用于区分同一角色下的不同级别)

#### 2). 其他
- role 可做列表 或 树
- power 中的 route 为 `unique`, 并且区分 `GET` 和 `POST`

### 3. 对自身的多层封装

#### 1). 字段
- `id` (必需)
- `name` (必需)
- `item_ids` (子集 ids, 必需)
- `item_type` (子集类型 必需, 可更换为 type, 表示该实体的封装类型)
- account_id (作者)

#### 2). 其他
- item_ids 和 item_type 实际和下方的 `多态` 实现类似
- item_ids 注意点同下方 `一对多 A: B_ids`

## 三. 其他
### 1. 一对多, 多对多, 多态

#### 1). 一对多
- hasMany, belongsTo 关联键在子表, 如 `type_id`, `user_id`
- `A: B_ids` 如果仅需要由 A 查多 B, 或数据量少是, 由 B 查 A, 则可使用, 否则请使用上面的 `A_id` 结构

#### 2). 多对多, 远程一对多, 远程多对多
- A <==> B 多对多 可拆分为 A <-=> B, 和 A <=-> B
- 远程一对多 可拆分为 A 和 B 的关系, 以及 B 和 C 的关系
- 远程多对多同理

#### 3). 多态
- 多态使用 `xx_type` 和 `xx_id` 实现, 当 type 改变时, id 对应的表也相应的改变
- 如果要设计的多种实体, 其 **相似性非常大**, 可以使用 `多态` 实现, 否则请分别实现每种实体表

---

Other : http://phabricator.vanthink.cn/F38093
